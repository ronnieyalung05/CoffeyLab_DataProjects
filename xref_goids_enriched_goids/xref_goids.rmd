### Cross check filter to keep proteins/rows in sample that have matching goIds with the same sample's enriched goIds

# uses `sample_data_normalized` from intial_data_transformation, and `gost_results` (function 2) from gprofiler_enrichment_analysis
```{r}
# one sample
one_sample_go_filtered <- filter_proteins_by_gost(sample_data_with_go, gost_results$HNPCC_CL, sample_col = "HNPCC_CL")

# all samples
all_sample_go_filtered <- filter_all_sample_by_go(sample_data_with_go, gost_results)
```

# single sample enriched go cross check filter
```{r}
filter_proteins_by_gost <- function(sample_data_with_go, gost_results, sample_col = NULL) {
  sample_data_with_go <- as.data.frame(sample_data_with_go)
  
  # Load progress bar
  library(progress)
  
  # Extract GO IDs from gost_results
  gost_go_ids <- unique(gost_results$result$term_id)
  
  # Initialize counters and containers
  kept_count <- 0
  lost_count <- 0
  lost_proteins <- data.frame()
  
  # Create progress bar
  pb <- progress_bar$new(
    total = nrow(sample_data_with_go),
    format = "[:bar] :percent | :current/:total proteins | eta: :eta"
  )
  
  # Initialize matched_goIds column
  sample_data_with_go$matched_goIds <- vector("list", nrow(sample_data_with_go))
  
  # Iterate through each protein
  for (i in seq_len(nrow(sample_data_with_go))) {
    pb$tick()
    
    # Extract this protein's GO IDs
    protein_goids <- sample_data_with_go$goIds[[i]]
    
    # Find intersection
    matched <- intersect(protein_goids, gost_go_ids)
    
    if (length(matched) > 0) {
      kept_count <- kept_count + 1
      sample_data_with_go$matched_goIds[[i]] <- matched
    } else {
      lost_count <- lost_count + 1
      lost_proteins <- rbind(lost_proteins, sample_data_with_go[i, ])
    }
  }
  
  # Keep only rows with at least one matched GO ID
  filtered_data <- subset(sample_data_with_go, lengths(matched_goIds) > 0)
  
  # === New: select only the columns we care about ===
  cols_to_keep <- c(
    "IdentifiedProteins", "AccessionNumberClean", "UniProtID", "EntryName",
    "GeneSymbol", "goIds", "goNames", "ontology", "matched_goIds"
  )
  # Include the sample column if specified
  if (!is.null(sample_col) && sample_col %in% colnames(filtered_data)) {
    cols_to_keep <- c(cols_to_keep, sample_col)
  }
  
  filtered_data <- filtered_data[, cols_to_keep, drop = FALSE]
  lost_proteins <- lost_proteins[, cols_to_keep, drop = FALSE]
  
  # Print summary
  message("✅ Proteins kept: ", kept_count)
  message("❌ Proteins lost: ", lost_count)
  
  # Return results as a list
  return(list(
    filtered_data = filtered_data,
    lost_proteins = lost_proteins,
    kept_count = kept_count,
    lost_count = lost_count
  ))
}
```

```{r}
filter_all_sample_by_go <- function(sample_data_with_go, gost_results_list, cores = detectCores() - 2) {
  library(parallel)
  
  # Helper to run filter_proteins_by_gost and pass sample column name
  run_filter <- function(sample_name, gost_item) {
    filter_proteins_by_gost(
      sample_data_with_go,
      gost_item,
      sample_col = sample_name
    )
  }
  
  # If the list is named, use those names as sample_col
  if (!is.null(names(gost_results_list))) {
    sample_names <- names(gost_results_list)
    
    results <- mcmapply(
      run_filter,
      sample_name = sample_names,
      gost_item = gost_results_list,
      SIMPLIFY = FALSE,
      mc.cores = cores
    )
    
    names(results) <- sample_names
  } else {
    # unnamed list: no sample_col
    results <- mclapply(
      gost_results_list,
      function(gost_item) filter_proteins_by_gost(sample_data_with_go, gost_item),
      mc.cores = cores
    )
  }
  
  return(results)
}
```